{"version":3,"file":"lite-queuer.js","names":["fn: (item: TValue) => void","options: LiteQueuerOptions<TValue>","item: TValue | undefined"],"sources":["../src/lite-queuer.ts"],"sourcesContent":["/**\n * Position type for addItem and getNextItem operations.\n *\n * - 'front': Operate on the front of the queue (FIFO for getNextItem)\n * - 'back': Operate on the back of the queue (LIFO for getNextItem)\n */\nexport type QueuePosition = 'front' | 'back'\n\n/**\n * Options for configuring a lite queuer instance\n */\nexport interface LiteQueuerOptions<TValue> {\n  /**\n   * Default position to add items to the queue\n   * @default 'back'\n   */\n  addItemsTo?: QueuePosition\n  /**\n   * Default position to get items from during processing\n   * @default 'front'\n   */\n  getItemsFrom?: QueuePosition\n  /**\n   * Function to determine priority of items in the queue\n   * Higher priority items will be processed first\n   * Return undefined for items that should use positional ordering\n   */\n  getPriority?: (item: TValue) => number | undefined\n  /**\n   * Initial items to populate the queue with\n   */\n  initialItems?: Array<TValue>\n  /**\n   * Maximum number of items allowed in the queue\n   */\n  maxSize?: number\n  /**\n   * Whether the queuer should start processing items immediately\n   * @default true\n   */\n  started?: boolean\n  /**\n   * Time in milliseconds to wait between processing items\n   * @default 0\n   */\n  wait?: number\n}\n\n/**\n * A lightweight class that creates a queue for processing items.\n *\n * This is an alternative to the Queuer in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core Queuer,\n * this version does not use TanStack Store for state management, has no devtools integration,\n * no callbacks, and provides only essential queueing functionality.\n *\n * The queuer supports FIFO (First In First Out), LIFO (Last In First Out), and priority-based\n * processing of items. Items can be processed automatically with configurable wait times\n * between executions, or processed manually using the execute methods.\n *\n * Features included:\n * - Automatic or manual processing of items\n * - FIFO, LIFO, and priority-based ordering\n * - Queue size limits with item rejection\n * - Configurable wait times between processing\n * - Batch processing capabilities\n * - Start/stop processing control\n * - Callback support for monitoring execution, rejection, and state change events\n *\n * Features NOT included (compared to core Queuer):\n * - No TanStack Store state management\n * - No devtools integration\n * - No item expiration functionality (no onExpire callback)\n * - No dynamic options updates (setOptions)\n * - No detailed state tracking (execution counts, etc.)\n *\n * Queue behavior:\n * - Default: FIFO (add to back, process from front)\n * - LIFO: Configure addItemsTo: 'back', getItemsFrom: 'back'\n * - Priority: Provide getPriority function; higher values processed first\n *\n * @example\n * ```ts\n * // Basic FIFO queue\n * const queue = new LiteQueuer((item: string) => {\n *   console.log('Processing:', item);\n * }, { wait: 100 });\n *\n * queue.addItem('task1');\n * queue.addItem('task2');\n * // Processes: task1, then task2 after 100ms delay\n * ```\n *\n * @example\n * ```ts\n * // Priority queue\n * const priorityQueue = new LiteQueuer((item: Task) => {\n *   processTask(item);\n * }, {\n *   getPriority: task => task.priority,\n *   wait: 500\n * });\n *\n * priorityQueue.addItem({ name: 'low', priority: 1 });\n * priorityQueue.addItem({ name: 'high', priority: 10 });\n * // Processes high priority task first\n * ```\n */\nexport class LiteQueuer<TValue> {\n  private items: Array<TValue> = []\n  private timeoutId: NodeJS.Timeout | null = null\n  private isRunning = true\n  private pendingTick = false\n\n  constructor(\n    public fn: (item: TValue) => void,\n    public options: LiteQueuerOptions<TValue> = {},\n  ) {\n    // Set defaults\n    this.options.addItemsTo = this.options.addItemsTo ?? 'back'\n    this.options.getItemsFrom = this.options.getItemsFrom ?? 'front'\n    this.options.maxSize = this.options.maxSize ?? Infinity\n    this.options.started = this.options.started ?? true\n    this.options.wait = this.options.wait ?? 0\n\n    this.isRunning = this.options.started\n\n    // Add initial items if provided\n    if (this.options.initialItems) {\n      for (const item of this.options.initialItems) {\n        this.addItem(item, this.options.addItemsTo, false)\n      }\n    }\n\n    // Start processing if enabled and has items\n    if (this.isRunning && this.items.length > 0) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Number of items currently in the queue\n   */\n  get size(): number {\n    return this.items.length\n  }\n\n  /**\n   * Whether the queue is empty\n   */\n  get isEmpty(): boolean {\n    return this.items.length === 0\n  }\n\n  /**\n   * Whether the queue is currently running (auto-processing items)\n   */\n  get isQueueRunning(): boolean {\n    return this.isRunning\n  }\n\n  /**\n   * Adds an item to the queue. If the queue is full, the item is rejected.\n   * Items can be inserted at the front or back, and priority ordering is applied if getPriority is configured.\n   *\n   * Returns true if the item was added, false if the queue is full.\n   *\n   * @example\n   * ```ts\n   * queue.addItem('task1');           // Add to default position (back)\n   * queue.addItem('task2', 'front');  // Add to front\n   * ```\n   */\n  addItem = (\n    item: TValue,\n    position: QueuePosition = this.options.addItemsTo!,\n    startProcessing: boolean = true,\n  ): boolean => {\n    // Check size limit\n    if (this.items.length >= this.options.maxSize!) {\n      return false\n    }\n\n    // Handle priority insertion\n    if (this.options.getPriority) {\n      const priority = this.options.getPriority(item)\n      if (priority !== undefined) {\n        // Find insertion point for priority\n        const insertIndex = this.items.findIndex((existing) => {\n          const existingPriority = this.options.getPriority!(existing)\n          // Treat undefined priority as negative infinity for comparison\n          const effectivePriority = existingPriority ?? -Infinity\n          return effectivePriority < priority\n        })\n\n        if (insertIndex === -1) {\n          this.items.push(item)\n        } else {\n          this.items.splice(insertIndex, 0, item)\n        }\n      } else {\n        // No priority, use position\n        this.insertAtPosition(item, position)\n      }\n    } else {\n      // No priority function, use position\n      this.insertAtPosition(item, position)\n    }\n\n    // Start processing if running and not already processing\n    if (startProcessing && this.isRunning && !this.pendingTick) {\n      this.tick()\n    }\n\n    return true\n  }\n\n  private insertAtPosition = (item: TValue, position: QueuePosition): void => {\n    if (position === 'front') {\n      this.items.unshift(item)\n    } else {\n      this.items.push(item)\n    }\n  }\n\n  /**\n   * Removes and returns the next item from the queue without executing the function.\n   * Use for manual queue management. Normally, use execute() to process items.\n   *\n   * @example\n   * ```ts\n   * const nextItem = queue.getNextItem();        // Get from default position (front)\n   * const lastItem = queue.getNextItem('back');  // Get from back (LIFO)\n   * ```\n   */\n  getNextItem = (\n    position: QueuePosition = this.options.getItemsFrom!,\n  ): TValue | undefined => {\n    if (this.items.length === 0) {\n      return undefined\n    }\n\n    let item: TValue | undefined\n\n    // When priority function is provided, always get from front (highest priority)\n    if (this.options.getPriority || position === 'front') {\n      item = this.items.shift()\n    } else {\n      item = this.items.pop()\n    }\n\n    return item\n  }\n\n  /**\n   * Removes and returns the next item from the queue and processes it using the provided function.\n   *\n   * @example\n   * ```ts\n   * queue.execute();        // Execute from default position\n   * queue.execute('back');  // Execute from back (LIFO)\n   * ```\n   */\n  execute = (position?: QueuePosition): TValue | undefined => {\n    const item = this.getNextItem(position)\n    if (item !== undefined) {\n      this.fn(item)\n    }\n    return item\n  }\n\n  /**\n   * Internal method that processes items in the queue with wait intervals\n   */\n  private tick = (): void => {\n    if (!this.isRunning) {\n      this.pendingTick = false\n      return\n    }\n\n    this.pendingTick = true\n\n    // Process items while queue is not empty\n    while (this.items.length > 0) {\n      const item = this.execute(this.options.getItemsFrom)\n      if (item === undefined) {\n        break\n      }\n\n      const wait = this.options.wait!\n      if (wait > 0) {\n        // Schedule next processing after wait time\n        this.timeoutId = setTimeout(() => this.tick(), wait)\n        return\n      }\n\n      // No wait time, continue processing immediately\n    }\n\n    this.pendingTick = false\n  }\n\n  /**\n   * Starts processing items in the queue. If already running, does nothing.\n   */\n  start = (): void => {\n    this.isRunning = true\n    if (!this.pendingTick && this.items.length > 0) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Stops processing items in the queue. Does not clear the queue.\n   */\n  stop = (): void => {\n    this.clearTimeout()\n    this.isRunning = false\n    this.pendingTick = false\n  }\n\n  /**\n   * Clears any pending timeout\n   */\n  private clearTimeout = (): void => {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n      this.timeoutId = null\n    }\n  }\n\n  /**\n   * Returns the next item in the queue without removing it.\n   *\n   * @example\n   * ```ts\n   * const next = queue.peekNextItem();        // Peek at front\n   * const last = queue.peekNextItem('back');  // Peek at back\n   * ```\n   */\n  peekNextItem = (position: QueuePosition = 'front'): TValue | undefined => {\n    if (this.items.length === 0) {\n      return undefined\n    }\n\n    if (this.options.getPriority || position === 'front') {\n      return this.items[0]\n    } else {\n      return this.items[this.items.length - 1]\n    }\n  }\n\n  /**\n   * Returns a copy of all items in the queue.\n   */\n  peekAllItems = (): Array<TValue> => {\n    return [...this.items]\n  }\n\n  /**\n   * Processes a specified number of items immediately with no wait time.\n   * If no numberOfItems is provided, all items will be processed.\n   *\n   * @example\n   * ```ts\n   * queue.flush();     // Process all items immediately\n   * queue.flush(3);    // Process next 3 items immediately\n   * ```\n   */\n  flush = (\n    numberOfItems: number = this.items.length,\n    position?: QueuePosition,\n  ): void => {\n    this.clearTimeout() // Clear any pending timeout\n    for (let i = 0; i < numberOfItems && this.items.length > 0; i++) {\n      this.execute(position)\n    }\n    // Restart normal processing if still running and has items\n    if (this.isRunning && this.items.length > 0 && !this.pendingTick) {\n      this.tick()\n    }\n  }\n\n  /**\n   * Processes all items in the queue as a batch using the provided function.\n   * The queue is cleared after processing.\n   *\n   * @example\n   * ```ts\n   * queue.flushAsBatch((items) => {\n   *   console.log('Processing batch:', items);\n   *   // Process all items together\n   * });\n   * ```\n   */\n  flushAsBatch = (batchFunction: (items: Array<TValue>) => void): void => {\n    const items = this.peekAllItems()\n    this.clear()\n    batchFunction(items)\n  }\n\n  /**\n   * Removes all items from the queue. Does not affect items being processed.\n   */\n  clear = (): void => {\n    this.items = []\n  }\n}\n\n/**\n * Creates a lightweight queue that processes items using the provided function.\n *\n * This is an alternative to the queue function in the core @tanstack/pacer package, but is more\n * suitable for libraries and npm packages that need minimal overhead. Unlike the core version,\n * this function creates a queuer with no external dependencies, devtools integration, or reactive state.\n *\n * @example\n * ```ts\n * const processItem = liteQueue((item: string) => {\n *   console.log('Processing:', item);\n * }, { wait: 1000 });\n *\n * processItem('task1');\n * processItem('task2');\n * // Processes each item with 1 second delay between them\n * ```\n */\nexport function liteQueue<TValue>(\n  fn: (item: TValue) => void,\n  options: LiteQueuerOptions<TValue> = {},\n): (item: TValue) => boolean {\n  const queuer = new LiteQueuer(fn, options)\n  return (item: TValue) => queuer.addItem(item)\n}\n"],"mappings":"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"}